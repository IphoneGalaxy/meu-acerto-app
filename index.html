<!DOCTYPE html>
<html lang="pt-PT">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Meu Acerto</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.json" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Meu Acerto" />
  <meta name="theme-color" content="#4338ca" />
  <link rel="apple-touch-icon" href="https://placehold.co/180x180/4338ca/ffffff?text=Acerto" />

  <!-- UI -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />

  <!-- React -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin="anonymous"></script>
  <!-- Add crossorigin to Babel script -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js" crossorigin="anonymous"></script>

  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <!-- Firebase compat (v10) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore-compat.js"></script>

  <style>
    body { font-family: 'Inter', sans-serif; }
    .modal-enter { animation: fadeIn .2s ease-out; }
    @keyframes fadeIn { from { opacity: 0; transform: scale(.98);} to { opacity: 1; transform: scale(1);} }
  </style>
</head>
<body class="bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200">
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
    const { useState, useEffect, useMemo, useRef } = React;
    const { createRoot } = ReactDOM;

    /* ================= Helpers ================= */
    const norm = (s) => (s ?? '').toString().normalize('NFD').replace(/[\u0300-\u036f]/g,'').trim().toLowerCase();
    const canonicalSplit = (s) => {
      const n = norm(s);
      if (n.includes('guilherme')) return 'Guilherme';
      if (n.includes('thais')) return 'Thais';
      return 'Dividido';
    };

    const shouldIgnoreDescription = (s) => {
      const n = norm(s).replace(/\s+/g, ' '); // normaliza acentos e espaços estranhos
      // ignora “Inclusão de Pagamento” (com ou sem acento/“de”/espaços extras/linhas)
      return n === 'inclusao de pagamento' || /\binclusao\b.*\bpagamento\b/.test(n);
    };

    // FIX: Handle both '.' and ',' as potential decimal separators
    const parseMoney = (input) => {
        if (typeof input === 'number') return input;
        if (!input) return NaN;
        // Handle masked input like "1.234,56" or "-1.234,56"
        let s = String(input).replace(/\s+/g,'').trim(); // Remove extra spaces
        const negative = s.startsWith('-');
        if (negative) s = s.substring(1); // Remove leading negative for parsing

        // Assume Brazilian/European style masking ('.' for thousands, ',' for decimal)
        // Remove thousands separators '.', replace decimal ',' with '.'
        const n = parseFloat(s.replace(/\./g,'').replace(',','.'));


        return Number.isFinite(n) ? (negative ? -n : n) : NaN;
    };


    const excelSerialToPT = (v) => {
      if (typeof v === 'number') {
        // Handle Excel date serial numbers
        const ms = Math.round((v - 25569) * 86400 * 1000);
        return new Date(ms).toLocaleDateString('pt-PT', { timeZone: 'UTC' });
      }
      if (typeof v === 'string') {
        // Handle 'dd/mm/yyyy'
        if (/^\d{2}\/\d{2}\/\d{4}$/.test(v)) return v;
        // Handle 'yyyy-mm-dd...'
        if (/^\d{4}-\d{2}-\d{2}/.test(v)) return new Date(v).toLocaleDateString('pt-PT', { timeZone: 'UTC' });
        // Handle 'd/m/yy' or 'dd/mm/yy'
        const m = v.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2})$/);
        if (m) return `${m[1].padStart(2,'0')}/${m[2].padStart(2,'0')}/20${m[3]}`;
      }
      // Fallback to current date if parsing fails
      return new Date().toLocaleDateString('pt-PT', { timeZone: 'UTC' });
    };
    const formatBRL = (v) => new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL'}).format(v || 0);
    const round2 = (v) => Math.round((v + Number.EPSILON)*100)/100;

    /* ================= UI Genéricos ================= */
    const Modal = ({ isOpen, onClose, children, titleId='modal-title' }) => {
      const contentRef = React.useRef(null);

      // (2) Use useCallback for stable onClose reference
      const onCloseStable = React.useCallback(() => onClose?.(), [onClose]);

      React.useEffect(() => {
        if (!isOpen) return;
        // Focus the first focusable element inside the modal when it opens
        setTimeout(() => {
          const node = contentRef.current;
          if (!node) return;
          // --- FIX: Don't steal focus if an element inside the modal already has it ---
          if (node.contains(document.activeElement)) return;
          // --- END FIX ---
          const focusables = node.querySelectorAll(
            'input,select,textarea,button,[tabindex]:not([tabindex="-1"])'
          );
          (focusables[0] || node).focus();
        }, 0);


        // Handle Escape key and Tab key for accessibility
        const onKeyDown = (e) => {
          if (e.key === 'Escape') { e.preventDefault(); onCloseStable(); } // Use stable callback
          if (e.key === 'Tab') {
            const node = contentRef.current;
            const focusables = node?.querySelectorAll('input,select,textarea,button,[tabindex]:not([tabindex="-1"])');
            if (!focusables || !focusables.length) return;
            const first = focusables[0], last = focusables[focusables.length-1];
            // Trap focus within the modal
            if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
            else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
          }
        };
        document.addEventListener('keydown', onKeyDown);
        return () => document.removeEventListener('keydown', onKeyDown);
      }, [isOpen, onCloseStable]); // Use stable callback in dependency array

      if (!isOpen) return null;
      return (
        // Modal backdrop
        <div className="fixed inset-0 bg-black/60 flex justify-center items-center p-4 z-50 modal-enter" onClick={onCloseStable} aria-hidden="true"> {/* Use stable callback */}
          {/* Modal content */}
          <div role="dialog" aria-modal="true" aria-labelledby={titleId}
               className="bg-white dark:bg-slate-800 rounded-2xl shadow-2xl w-full max-w-md m-4 outline-none"
               onClick={(e)=>e.stopPropagation()} ref={contentRef} tabIndex={-1}>
            {children}
          </div>
        </div>
      );
    };

    const UserSelectionScreen = ({ onSelectUser }) => {
      const users = ['Guilherme', 'Thais'];
      return (
        <div className="min-h-screen flex flex-col justify-center items-center p-6">
          <h1 className="text-4xl font-bold mb-2">Meu Acerto</h1>
          <p className="text-lg text-slate-600 dark:text-slate-400 mb-8">Quem está a usar?</p>
          <div className="space-y-4 w-full max-w-xs">
            {users.map(u => (
              <button key={u} onClick={()=>onSelectUser(u)}
                className={`w-full py-3 rounded-xl text-white font-semibold shadow-lg hover:brightness-110 transition
                 ${u==='Thais' ? 'bg-pink-600' : 'bg-indigo-600'}`}>
                {u}
              </button>
            ))}
          </div>
        </div>
      );
    };

    /* ================= Dashboard ================= */
    const Dashboard = ({ user, onLogout, db, appId, userId }) => { // appId might be null/default outside Canvas
      // State variables
      const [expenses, setExpenses] = useState([]); // All expenses
      const [installmentPlans, setInstallmentPlans] = useState([]); // Installment plans
      const [filter, setFilter] = useState('Todos'); // Current expense filter
      const [scope, setScope] = useState('geral'); // Current calculation scope ('geral', 'cartao', 'pixboleto')
      const [isAddOpen, setIsAddOpen] = useState(false); // Add/Edit modal state
      const [isImportModalOpen, setImportModalOpen] = useState(false); // Import confirmation modal state
      const [isImporting, setIsImporting] = useState(false); // Import loading state
      const [isClearModalOpen, setIsClearModalOpen] = useState(false); // Clear all data modal state
      const [importedExpenses, setImportedExpenses] = useState([]); // Expenses parsed from imported file
      const fileInputRef = useRef(null); // Ref for file input

      // Add/Edit form state
      const [fDesc, setFDesc] = useState(''); // Description
      const [fValor, setFValor] = useState(''); // Amount (as string, BR format)
      const [fData, setFData] = useState(() => new Date().toLocaleDateString('pt-PT', { timeZone:'UTC'})); // Date
      const [fTipo, setFTipo] = useState('Cartão'); // Type ('Cartão', 'Pix', 'Boleto', 'Ajuste')
      const [fSplit, setFSplit] = useState('Dividido'); // Split ('Dividido', 'Guilherme', 'Thais')
      const [fFonte, setFFonte] = useState(user === 'Guilherme' ? 'Cartão Guilherme (final 2581)' : 'Cartão Thais (final 1009)'); // Payment source (Card specific or Type)
      const [fParcela, setFParcela] = useState(''); // Installment info (e.g., '2/12')
      const [salvando, setSalvando] = useState(false); // Saving state (for button label/disable)
      const [editingId, setEditingId] = useState(null); // ID of the expense being edited, null if adding
      const [ajusteValor, setAjusteValor] = useState(''); // Quick adjustment amount (Thais only)
      const [ajusteDesc, setAjusteDesc] = useState(''); // Quick adjustment description (Thais only)

      // --- Additions for Value Input Mask ---
      const valorRef = useRef(null); // ref pro input de valor

      // formata string de dígitos para "pt-BR" com 2 casas
      const formatBRLInput = (digits, negative=false) => {
        const n = (Number(digits) || 0) / 100;
        const fmt = n.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        return negative ? `-${fmt}` : fmt;
      };

      // handler do input
      const handleValorChange = (e) => {
        const raw = e.target.value;
        const negative = raw.trim().startsWith('-');           // permite valores negativos se digitar "-"
        const digits = raw.replace(/\D/g, '');                  // só números
        if (!digits) { setFValor(negative ? '-' : ''); return; } // Allow just '-'
        setFValor(formatBRLInput(digits, negative));
      };

      // mantém o cursor sempre no fim após formatar
      useEffect(() => {
        const el = valorRef.current;
        if (!el || document.activeElement !== el) return; // Only run if the input is focused
        const pos = el.value.length;
        try { el.setSelectionRange(pos, pos); } catch (e) { console.warn("Could not set cursor position", e)} // Catch potential errors in edge cases
      }, [fValor]); // Run whenever the formatted value changes
      // --- END Additions ---


      // Delete confirmation state
      const [isDelOpen, setDelOpen] = useState(false); // Delete modal state
      const [delTarget, setDelTarget] = useState(null); // Expense targeted for deletion
      const [deleting, setDeleting] = useState(false); // Deleting state

      // Helper to open delete modal
      const openDelete = (exp) => { setDelTarget(exp); setDelOpen(true); };
      // Helper to close delete modal
      const closeDelete = () => { setDelOpen(false); setDelTarget(null); };

      // Theme and user context helpers
      const otherUser = user === 'Guilherme' ? 'Thais' : 'Guilherme';
      const theme = user === 'Thais'
        ? { text:'text-pink-600', darkText:'dark:text-pink-400', bg:'bg-pink-600', hover:'hover:bg-pink-700', border:'border-pink-500' }
        : { text:'text-indigo-600', darkText:'dark:text-indigo-400', bg:'bg-indigo-600', hover:'hover:bg-indigo-700', border:'border-indigo-500' };

      // --- FIX: Use direct collection names for standalone deployment ---
      const expensesColRef = useMemo(() => {
        if (!db) return null;
        return db.collection('expenses');
      }, [db]);
      const plansColRef = useMemo(() => {
        if (!db) return null;
        return db.collection('installmentPlans');
      }, [db]);
      // --- END FIX ---


      // Firestore real-time listeners
      useEffect(() => {
        // Only attach listeners if refs are valid
        if (!expensesColRef || !plansColRef) return;

        // Subscribe to expenses collection
        const unsub1 = expensesColRef.onSnapshot(s => setExpenses(s.docs.map(d => ({ id:d.id, ...d.data()}))), err => console.error("expenses snapshot error", err));
        // Subscribe to installment plans collection
        const unsub2 = plansColRef.onSnapshot(s => setInstallmentPlans(s.docs.map(d => ({ id:d.id, ...d.data()}))), err => console.error("plans snapshot error", err));
        // Unsubscribe on component unmount
        return () => { unsub1(); unsub2(); };
      }, [expensesColRef, plansColRef]); // Dependencies are the refs themselves

      // Automatically generate missing past installments based on plans
      useEffect(() => {
        // Ensure refs are valid before proceeding
        // appId is no longer needed here as the ref path doesn't depend on it
        if (installmentPlans.length === 0 || !db || !expensesColRef) return;
        const today = new Date();
        const batch = db.batch(); // Use batch for efficiency
        let hasWrites = false; // Track if any writes are needed

        for (const plan of installmentPlans) {
          // Skip incomplete plans
          if (!plan.startDate || !plan.numberOfInstallments || !plan.totalAmount) continue;

          const deletedSet = new Set(plan.deletedParcels || []); // Track manually deleted installments
          // Robust date parsing, assuming dd/mm/yyyy
          const dateParts = String(plan.startDate).split('/');
          if (dateParts.length !== 3) continue; // Skip if date format is wrong
          const [dd, mm, yyyy] = dateParts.map(Number);
          if (isNaN(dd) || isNaN(mm) || isNaN(yyyy) || mm < 1 || mm > 12) continue; // Basic date validation
          const start = new Date(yyyy, mm-1, dd); // Plan start date

          const per = round2(plan.totalAmount / plan.numberOfInstallments); // Amount per installment
          const last = round2(plan.totalAmount - per * (plan.numberOfInstallments - 1)); // Amount for the last installment

          // Iterate through expected installments
          for (let i=0;i<plan.numberOfInstallments;i++) {
            const d = new Date(start.getFullYear(), start.getMonth()+i, start.getDate(), 12); // Expected date for this installment
            // Check if the installment date is in the past
            if (d <= today) {
              const num = i+1;
              const parcelaKey = `${num}/${plan.numberOfInstallments}`; // e.g., '1/12'
              // Skip if this specific installment was manually deleted
              if (deletedSet.has(parcelaKey)) continue;

              // Check if an expense already exists for this installment
              const exists = expenses.some(e => e.installmentPlanId===plan.id && e.parcela===parcelaKey);
              if (!exists) {
                // Create the missing installment expense
                batch.set(expensesColRef.doc(), {
                  installmentPlanId: plan.id,
                  description: plan.description,
                  amount: num === plan.numberOfInstallments ? last : per, // Use 'last' amount for the final installment
                  date: d.toLocaleDateString('pt-PT', { timeZone:'UTC'}),
                  parcela: parcelaKey,
                  split: plan.split,
                  type: plan.type,
                  paymentSource: plan.paymentSource,
                  paidBy: 'Cartão' // Installments are assumed to be card payments
                });
                hasWrites = true; // Mark that a write is needed
              }
            }
          }
        }
        // Commit the batch if any installments were added
        if (hasWrites) batch.commit().catch(console.error);
      }, [installmentPlans, expenses, db, expensesColRef]); // Removed appId dependency

      /* ===== actions ===== */

      // Populate edit form and open modal
      const openEdit = (e) => {
        setEditingId(e.id);
        setFDesc(e.description || '');
        // --- FIX: Format value correctly when opening edit ---
        setFValor(
          (e.amount != null)
            ? Number(e.amount).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })
            : ''
        );
        // --- END FIX ---
        setFData(e.date || new Date().toLocaleDateString('pt-PT', { timeZone: 'UTC' }));
        setFTipo(e.type || 'Cartão');
        setFSplit(e.split || 'Dividido');
        setFFonte(
          e.type === 'Cartão'
            ? (e.paymentSource || (user === 'Guilherme' ? 'Cartão Guilherme (final 2581)' : 'Cartão Thais (final 1009)'))
            : e.type // For Pix/Boleto/Ajuste, source is the type itself
        );
        setFParcela(e.parcela || '');
        setIsAddOpen(true);
      };

      // Handle expense deletion
      const doDelete = async () => {
        if (!delTarget || !expensesColRef || !plansColRef) return; // Ensure refs are valid
        setDeleting(true);
        try {
          const expRef = expensesColRef.doc(delTarget.id);

          // Special handling for installments: mark as deleted in the plan
          if (delTarget.installmentPlanId && delTarget.parcela) {
            const planRef = plansColRef.doc(delTarget.installmentPlanId);
            // Use a transaction to update the plan and delete the expense atomically
            await db.runTransaction(async (t) => {
              const planSnapshot = await t.get(planRef);
              // Check if plan exists before trying to access data
              if (!planSnapshot.exists) {
                 console.warn(`Installment plan ${delTarget.installmentPlanId} not found during delete.`);
                 t.delete(expRef); // Just delete the expense if plan is missing
                 return;
              }
              const currentDeleted = (planSnapshot.data()?.deletedParcels || []);
              const key = String(delTarget.parcela);
              // Add the parcela key to the deleted list if not already present
              const nextDeleted = currentDeleted.includes(key) ? currentDeleted : [...currentDeleted, key];
              t.update(planRef, { deletedParcels: nextDeleted });
              t.delete(expRef); // Delete the actual expense document
            });
          } else {
            // Normal expense deletion
            await expRef.delete();
          }
          closeDelete(); // Close modal on success
        } catch (e) {
          console.error("Deletion error:", e);
          // alert('Falha ao excluir.'); // Avoid using alert
        } finally {
          setDeleting(false);
        }
      };

      // Normalize installment input (e.g., '2 / 12' -> '2/12')
      const normalizeParcelaInput = (s) => {
        let p = String(s || '').trim();
        // Handle "Única" explicitly, return empty string which becomes null later
        if (norm(p) === 'unica') return '';
        if (!p) return ''; // Empty means keep current value on update
        // Check for 'num / den' format
        if (/^\d+\s*\/\s*\d+$/.test(p)) {
          const [a,b] = p.split('/').map(x => Number(x.trim()));
          if (a > 0 && b > 0 && a <= b) return `${a}/${b}`; // Valid
          return ''; // Invalid (e.g., 13/12)
        }
        // Check for 'num de den' or similar formats
        const m = p.match(/(\d+)\D+(\d+)/);
        if (m) {
          const a = Number(m[1]), b = Number(m[2]);
          if (a > 0 && b > 0 && a <= b) return `${a}/${b}`; // Valid
        }
        return ''; // Invalid format
      };

      // Save new or edited expense
      const salvarLancamento = async () => {
        if (!expensesColRef) return; // Ensure ref is valid
        const val = parseMoney(fValor); // Parse amount string (now handles masked input)
        // Basic validation
        if (!fDesc || !Number.isFinite(val)) {
          console.warn('Descrição ou valor inválido.'); // Avoid alert
          return;
        }

        // Validate installment format if provided
        const parcelaNorm = normalizeParcelaInput(fParcela);
        if (fParcela && norm(fParcela) !== 'unica' && !parcelaNorm) { // Allow 'unica' even though it normalizes to ''
            console.warn('Parcela inválida. Use o formato N/T ou deixe em branco/Única.'); // Avoid alert
            return;
        }


        setSalvando(true);
        try {
          // Base payload for both add and update
          const payloadBase = {
            description: fDesc,
            amount: val, // Use the correctly parsed numeric value
            date: fData, // Assume fData is already in 'dd/mm/yyyy' format
            split: fTipo === 'Ajuste' ? 'Thais' : fSplit, // Force split to Thais for Adjustments
            type: fTipo,
            paymentSource: fTipo === 'Cartão' ? fFonte : fTipo, // Source is specific card or the type itself
            paidBy: fTipo === 'Cartão' ? 'Cartão' : (fTipo === 'Ajuste' ? 'Thais' : user), // 'Cartão' if card, Thais if Ajuste, otherwise the current user
          };

          if (editingId) {
            // UPDATE operation
            const payload = { ...payloadBase };
            // Only update 'parcela' if the input field was touched
            // Empty input '' means clear the parcela field (set to null)
            payload.parcela = parcelaNorm || null; // Always update parcela field on edit
            await expensesColRef.doc(editingId).update(payload);
            setEditingId(null); // Reset editing state
          } else {
            // ADD operation
            // Add 'parcela' (normalized or null) to the payload
            await expensesColRef.add({ ...payloadBase, parcela: parcelaNorm || null });
          }

          // Reset form and close modal on success
          setIsAddOpen(false);
          setFDesc(''); setFValor(''); setFParcela('');
          // Reset default source/type after saving
          setFTipo('Cartão');
          setFFonte(user === 'Guilherme' ? 'Cartão Guilherme (final 2581)' : 'Cartão Thais (final 1009)');
          setFSplit('Dividido');

        } catch (e) {
          console.error("Save error:", e);
          // alert('Falha ao salvar.'); // Avoid alert
        } finally {
          setSalvando(false);
        }
      };

      // Add quick adjustment (Thais -> Guilherme)
      const adicionarAjusteRapido = async () => {
        if (!expensesColRef) return; // Ensure ref is valid
        if (user !== 'Thais') {
          console.warn('Ajuste só pode ser lançado pela Thais.'); // Avoid alert
          return;
        }
        const val = parseMoney(ajusteValor); // Parse potentially masked value
        // Adjustment must be positive
        if (!(val > 0)) {
          console.warn('Informe um valor POSITIVO para o ajuste.'); // Avoid alert
          return;
        }

        try {
          await expensesColRef.add({
            description: (ajusteDesc?.trim() || 'Ajuste (Thais → Guilherme)'),
            amount: val,
            date: new Date().toLocaleDateString('pt-PT', { timeZone:'UTC' }),
            split: 'Thais', // Adjustments don't count towards shared expenses, assigned solely to Thais
            type: 'Ajuste',
            paymentSource: 'Ajuste',
            paidBy: 'Thais', // Paid by Thais
            parcela: null
          });
          // Reset adjustment form fields
          setAjusteValor(''); setAjusteDesc('');
        } catch (e) {
          console.error("Adjustment error:", e);
          // alert('Falha ao registrar ajuste.'); // Avoid alert
        }
      };

      // Delete all documents in a collection in batches
      const deleteCollection = async (colRef, chunkSize=450) => {
        if (!colRef) return; // Ensure ref is valid
        let snap = await colRef.limit(chunkSize).get();
        while (!snap.empty) {
          const batch = db.batch();
          snap.docs.forEach(d => batch.delete(d.ref));
          await batch.commit();
          snap = await colRef.limit(chunkSize).get(); // Get next batch
        }
      };

      // Confirm and clear all expenses and plans
      const confirmAndClearAll = async () => {
        // Ensure refs are valid before proceeding
        if (!expensesColRef || !plansColRef) {
             console.error("Firestore refs not ready for clear all.");
             return;
        }
        try {
          await deleteCollection(expensesColRef);
          await deleteCollection(plansColRef);
        } catch (e) {
          console.error("Clear all error:", e);
        } finally {
          setIsClearModalOpen(false); // Close modal regardless of success/failure
        }
      };

      // (4) Export: formatação de data simplificada
      const exportXLSX = async () => {
        const wb = XLSX.utils.book_new();

        // ===== "Lancamentos" Sheet =====
        // Convert 'dd/mm/yyyy' string to JS Date object for Excel
        const toDateObj = (pt) => {
          const m = String(pt || '').match(/^(\d{2})\/(\d{2})\/(\d{4})$/);
          if (!m) return null;
          const dd = Number(m[1]), mm = Number(m[2]) - 1, yyyy = Number(m[3]);
          return new Date(Date.UTC(yyyy, mm, dd)); // Use UTC to avoid timezone issues with Date objects
        };

        // Parse installment string 'N/T' into {num, tot}
        const parseParcelaParts = (s) => {
          const m = String(s || '').match(/(\d+)\s*\/\s*(\d+)/);
          return m ? { num: Number(m[1]), tot: Number(m[2]) } : { num: null, tot: null };
        };

        // Map expenses data for the sheet, including hidden helper columns for sorting
        const rows = expenses.map(e => {
          const { num, tot } = parseParcelaParts(e.parcela);
          return {
            'Data': toDateObj(e.date) || e.date || '', // Use Date object if possible
            'Descrição': e.description || '',
            'Valor': Number(e.amount || 0),
            'Tipo': e.type || '',
            'Divisão': e.split || '',
            'Origem': e.paymentSource || '',
            'Pago por': e.paidBy || '',
            'Parcela': e.parcela || '',
            'Parcela Nº (oculto)': num,                  // Hidden column for sorting
            'Parcela Total (oculto)': tot,                  // Hidden column for sorting
            'Parcelado? (ordem oculta)': num != null ? 1 : 0, // Hidden column (0=not installment, 1=is installment)
          };
        });

        // Define header order explicitly
        const headers = [
          'Data','Descrição','Valor','Tipo','Divisão','Origem','Pago por','Parcela',
          'Parcela Nº (oculto)','Parcela Total (oculto)','Parcelado? (ordem oculta)'
        ];

        // Create sheet from data, specifying headers and enabling cellDates
        const ws1 = XLSX.utils.json_to_sheet(rows, { header: headers, cellDates: true });

        // Apply formatting and autofilter
        const range1 = XLSX.utils.decode_range(ws1['!ref'] || 'A1:A1');

        // Format 'Valor' column as BRL currency
        const valorColIndex = headers.indexOf('Valor');
        if (valorColIndex > -1) {
          for (let R = 1; R <= range1.e.r; R++) { // Start from row 1 (data)
            const addr = XLSX.utils.encode_cell({ r: R, c: valorColIndex });
            const cell = ws1[addr];
            if (cell && typeof cell.v === 'number') {
              cell.t = 'n'; // Ensure type is number
              cell.z = 'R$ #,##0.00'; // BRL format string
            }
          }
        }

        // Format 'Data' column as dd/mm/yyyy (simplified)
        const dataColIndex = headers.indexOf('Data');
        if (dataColIndex > -1) {
          for (let R = 1; R <= range1.e.r; R++) { // Start from row 1 (data)
            const addr = XLSX.utils.encode_cell({ r: R, c: dataColIndex });
            const cell = ws1[addr];
            // Directly apply format; cellDates:true handles the value conversion
            if (cell) cell.z = 'dd/mm/yyyy';
          }
        }

        // Apply AutoFilter to the entire data range including header
        ws1['!autofilter'] = { ref: XLSX.utils.encode_range({ s: { r: 0, c: 0 }, e: { r: range1.e.r, c: headers.length - 1 } }) };

        // Set column widths and hide helper columns
        ws1['!cols'] = [
          { wch: 12 }, // Data
          { wch: 42 }, // Descrição
          { wch: 12 }, // Valor
          { wch: 10 }, // Tipo
          { wch: 12 }, // Divisão
          { wch: 28 }, // Origem
          { wch: 12 }, // Pago por
          { wch: 10 }, // Parcela
          { hidden: true }, // Parcela Nº (oculto)
          { hidden: true }, // Parcela Total (oculto)
          { hidden: true }, // Parcelado? (ordem oculta)
        ];

        XLSX.utils.book_append_sheet(wb, ws1, 'Lancamentos');


        // ===== "Resumo" Sheet =====
        // Create summary data array (using calculated memoized values)
        const resumo = [
          ['Usuário', user],
          ['Escopo exibido', scope], // Filter scope ('geral', 'cartao', 'pixboleto')
          [], // Spacer row
          ['Parte do Guilherme (escopo)', partsScoped.g],
          ['Parte da Thais (escopo)',     partsScoped.t],
          ['Dif. de gastos (escopo)', difGastos],
          [`Se ${user} quitar tudo (escopo), recebe de ${otherUser}`, valorDevolverSePagarTudo],
          [], // Spacer row
          ['Cartões - Total (geral)', cardTotals.grandTotal],
          ['Cartão Guilherme 2581 (geral)', cardTotals.guilhermeCardTotal],
          ['Cartão Thais 1009 (geral)', cardTotals.thaisCardTotal],
          ['Cartão Digital 7292 (geral)', cardTotals.digitalCardTotal],
          [], // Spacer row
          ['Pagamentos (Pix/Boleto/Ajuste) por Guilherme (geral)', gPaid],
          ['Pagamentos (Pix/Boleto/Ajuste) por Thais (geral)', tPaid],
          [], // Spacer row
          [`Saldo ${user} para ${otherUser} (geral, Pix/Boleto)`, saldoUsuario], // Positive = receive, Negative = owe
          ['Saldo Devedor Thais para Guilherme (geral, Cartão+Pix+Boleto)', saldoDevedorThais],
        ];
        const ws2 = XLSX.utils.aoa_to_sheet(resumo);

        // Apply currency format to relevant summary rows (adjust indices if `resumo` changes)
        const currencyRowsIndices = [3, 4, 5, 6, 8, 9, 10, 11, 13, 14, 16, 17];
        currencyRowsIndices.forEach(rowIndex => {
          const addr = `B${rowIndex + 1}`; // +1 because sheet rows are 1-based
          if (ws2[addr] && typeof ws2[addr].v === 'number') {
            ws2[addr].t = 'n';
            ws2[addr].z = 'R$ #,##0.00';
          }
        });

        // Adjust column widths for summary sheet
        ws2['!cols'] = [{ wch: 50 }, { wch: 15 }];

        XLSX.utils.book_append_sheet(wb, ws2, 'Resumo');

        // Generate filename
        const filename = `meu-acerto-${user.toLowerCase()}-${new Date().toISOString().slice(0,10)}.xlsx`;

        // Attempt download using different methods for compatibility
        try {
          // Method 1: Direct writeFileXLSX (preferred)
          if (XLSX.writeFileXLSX) {
            XLSX.writeFileXLSX(wb, filename);
          } else {
            // Fallback to older writeFile
            XLSX.writeFile(wb, filename);
          }
          return; // Success
        } catch (err) {
          console.warn('XLSX.writeFile failed, trying ObjectURL fallback:', err);
        }

        try {
          // Method 2: Fallback using Blob and ObjectURL
          const wbArray = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
          const blob = new Blob([wbArray], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = filename; a.rel = 'noopener';
          document.body.appendChild(a); a.click(); a.remove(); // Trigger download
          URL.revokeObjectURL(url); // Clean up
        } catch (finalErr) {
          console.error('XLSX Export Error (all methods failed):', finalErr);
          // alert('Falha ao exportar.'); // Avoid using alert
        }
      };

      // Handle file upload for import
      const handleFileUpload = async (event) => {
        try {
          const file = event.target.files?.[0]; if (!file) return;
          // Determine if CSV or Excel file
          const isCSV = file.type === 'text/csv' || file.name.toLowerCase().endsWith('.csv');
          // Read file content (text for CSV, array buffer for Excel)
          const readFile = () => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            if (isCSV) reader.readAsText(file, 'utf-8'); else reader.readAsArrayBuffer(file);
          });

          const data = await readFile();
          // Parse file content using SheetJS
          const wb = isCSV ? XLSX.read(data, {type:'string'}) : XLSX.read(data, {type:'array'});
          const sheet = wb.Sheets[wb.SheetNames[0]]; // Get the first sheet

          // A) Detect the correct header row
          const rowsAoA = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' }); // Read as array of arrays
          const headerNorm = (h) => norm(String(h)).replace(/\s+/g,'').replace(/[^a-z0-9]/g,''); // Normalizer for headers

          // FIX: Improved header detection
          let headerRow = rowsAoA.findIndex(r => {
             const normalizedHeaders = r.map(h => headerNorm(String(h)));
             // Check for essential normalized headers present in the sample CSV
             return normalizedHeaders.includes('datadecompra') && // 'Data de compra'
                    normalizedHeaders.includes('descricao') &&
                    normalizedHeaders.includes('valoremr');    // 'Valor (em R$)'
          });
          // FIX: Fallback to the SECOND row (index 1) if specific headers aren't found
          if (headerRow < 0) {
              console.warn("Could not reliably detect header row based on content, falling back to row 2 (index 1).")
              headerRow = 1;
          }
          // --- END FIX ---

          // Ensure headerRow is within bounds
          if (headerRow >= rowsAoA.length) {
              console.error("Header row index out of bounds.");
              return;
          }


          const headers = rowsAoA[headerRow]; // Actual headers
          console.log("Detected headers:", headers, "at row index:", headerRow);

          // Convert data rows (after header) into objects using the found headers
          const rows = rowsAoA.slice(headerRow + 1).map(r => {
            const o = {};
            headers.forEach((h, i) => { if (h) o[h] = r[i]; }); // Map values to header keys
            return o;
          });

          // B) Flexible 'pick' function using 'includes'
          const pick = (row, tokens) => {
            for (const k of Object.keys(row)) {
              const nk = headerNorm(k); // Normalize the key from the row object
              for (const t of tokens) { // Check against each possible token
                if (nk === t || nk.includes(t)) return row[k]; // Match if exact or includes token
              }
            }
            return ''; // Return empty string if no match found
          };

          // Map row objects to the expected expense format
          const mapped = rows.map((row, index) => {
            // Use 'pick' with various possible header names for each field
            const desc = pick(row, ['descricao','descrição','description']);
            if (shouldIgnoreDescription(desc)) return null; // pula essa linha

            // Prioritize BRL amount, then fall back to others
            const rawAmount = (() => {
              // Headers like "Valor (em R$)" normalize to "valoremr"
              const preferBRL = pick(row, ['valoremr','valorbrl','brl']);
              // If BRL specific header found, use it, otherwise look for general/USD terms
              return preferBRL || pick(row, ['valor','amount','preco','preço','price','valortotal','valoremus','usd']);
            })();

            // Expanded date tokens
            const rawDate = pick(row, ['data','date','datacompra','datadecompra','datalancto','datatransacao','datatransação']);
            const rawType = pick(row, ['tipo','type','formapagamento']);
            // FIX: Add more tokens for source and card name
            const rawSource = pick(row, ['origem','fonte','paymentsource','source','cartao','cartão', 'finaldocartao', 'finaldocartão']);
            const rawCardName = pick(row, ['nomecartao', 'nomecartão', 'nomenocartao', 'nomenocartão']);
            // END FIX
            const rawParcela = pick(row, ['parcela','installment']);
            const rawSplit = pick(row, ['split','divisao','divisão','rateio']);
            const rawPaidBy = pick(row,['paidby','pagopor']); // Note: CSV doesn't have explicit 'paid by' for Pix/Boleto

            // Normalize Type (Default to Cartão if not specified)
            const t = norm(rawType);
            const type = t.includes('ajuste') ? 'Ajuste' : t.includes('pix') ? 'Pix' : t.includes('boleto') ? 'Boleto' : 'Cartão'; // Default 'Cartão'

            // Parse Amount and validate essential fields
            const amount = parseMoney(String(rawAmount)); // Use parseMoney which handles masked input
            if (!Number.isFinite(amount) || !desc) {
                console.warn(`Skipping row ${index + headerRow + 2}: Invalid amount ('${rawAmount}' -> ${amount}) or description ('${desc}')`);
                return null; // Skip invalid rows
            }


            // Parse/Format Date
            const date = excelSerialToPT(rawDate);
            if (!date) { // Add check for valid date parsing
                 console.warn(`Skipping row ${index + headerRow + 2}: Invalid date ('${rawDate}')`);
                 return null;
            }


            // FIX: Determine Payment Source using Final do Cartao / Nome no Cartao if available
            const finalCartao = norm(rawSource);
            let resolvedSource = type === 'Cartão' ? (user === 'Guilherme' ? 'Cartão Guilherme (final 2581)' : 'Cartão Thais (final 1009)') : type; // Default

            if (type === 'Cartão') {
                if (finalCartao.includes('2581')) resolvedSource = 'Cartão Guilherme (final 2581)';
                else if (finalCartao.includes('1009')) resolvedSource = 'Cartão Thais (final 1009)';
                else if (finalCartao.includes('7292')) resolvedSource = 'Cartão Digital (final 7292)';
                // Fallback using rawCardName if finalCartao is empty or didn't match
                else if (rawCardName) {
                    const nameNorm = norm(rawCardName);
                    if (nameNorm.includes('guilherme')) resolvedSource = 'Cartão Guilherme (final 2581)';
                    else if (nameNorm.includes('thais')) resolvedSource = 'Cartão Thais (final 1009)';
                    // Add check for digital card name if known, e.g., if (nameNorm.includes('digital')) ...
                }
                 // If still unsure, keep the default based on logged-in user
            } else {
                 resolvedSource = type; // Non-card type
            }
            const paymentSource = resolvedSource; // Final source
            // --- END FIX ---

            // Determine Split and Paid By
            const split = canonicalSplit(rawSplit || (amount < 0 ? user : 'Dividido')); // Default Split: If negative amount assume user, else divided. Explicit column overrides.
            // FIX: Determine Paid By more accurately for non-card
            let resolvedPaidBy = user; // Default to current user for Pix/Boleto
             if (type === 'Cartão') {
                 resolvedPaidBy = 'Cartão'; // Card payments are always 'Cartão'
             } else if (type === 'Ajuste') {
                 resolvedPaidBy = 'Thais'; // Adjustments are always Thais -> Gui
             } else { // Pix or Boleto - try to infer from card name if available from CSV
                 const nameNorm = norm(rawCardName);
                 if (nameNorm.includes('guilherme')) resolvedPaidBy = 'Guilherme';
                 else if (nameNorm.includes('thais')) resolvedPaidBy = 'Thais';
                 // Explicit PaidBy column overrides inference
                 if (rawPaidBy) {
                      const paidNorm = norm(rawPaidBy);
                      if (paidNorm.includes('thais')) resolvedPaidBy = 'Thais';
                      else if (paidNorm.includes('guilherme')) resolvedPaidBy = 'Guilherme';
                 }
                 // else keep default 'user'
             }
             const paidBy = resolvedPaidBy; // Final paidBy
             // --- END FIX ---

            // Normalize Installment
            let parcela = normalizeParcelaInput(rawParcela); // Use the robust normalizer
            if (!parcela) parcela = null; // Ensure null if empty or invalid

            // Return the structured expense object
            return { description: desc, amount, date, split, paidBy, paymentSource, type, parcela };
          }).filter(Boolean); // Filter out null results from invalid rows

          console.log(`Successfully mapped ${mapped.length} rows from file.`);


          // Show import confirmation modal if valid rows were found
          if (mapped.length === 0) {
            console.warn('Não encontrei linhas válidas para importar.'); // Avoid alert
            return;
          }
          setImportedExpenses(mapped);
          setImportModalOpen(true);
        } catch (e) {
          console.error('File Upload/Parse Error:', e);
          // alert('Falha ao carregar ficheiro.'); // Avoid using alert
        } finally {
          // Reset file input to allow re-uploading the same file
          if (event.target) event.target.value = '';
        }
      };

      // Confirm and execute the import process
      const confirmImport = async () => {
        if (isImporting || !expensesColRef) return; // Prevent double import, ensure ref valid
        setIsImporting(true);
        try {
          // Filter out potential duplicates already present in Firestore
          const unique = importedExpenses.filter(imp =>
            !expenses.some(ex => // Check if an existing expense 'ex' matches the imported 'imp'
              ex.description === imp.description &&
              Math.abs(ex.amount - imp.amount) < 0.01 && // Compare amounts with tolerance
              ex.date === imp.date &&
              ex.parcela === imp.parcela && // Null vs Null should match
              ex.paymentSource === imp.paymentSource &&
              ex.type === imp.type &&
              canonicalSplit(ex.split) === canonicalSplit(imp.split) // Compare normalized split
            )
          );
           console.log(`Importing ${unique.length} unique expenses out of ${importedExpenses.length} mapped.`);

          // Add unique expenses to Firestore in batches
          const chunkSize = 450; // Firestore batch write limit is ~500
          for (let i = 0; i < unique.length; i += chunkSize) {
            const chunk = unique.slice(i, i + chunkSize);
            const batch = db.batch();
            chunk.forEach(e => batch.set(expensesColRef.doc(), e)); // Add each expense in the chunk to the batch
            console.log(`Committing batch ${Math.floor(i/chunkSize) + 1} with ${chunk.length} expenses.`);
            await batch.commit(); // Commit the batch
          }
          // Clear import state and close modal on success
          setImportedExpenses([]);
          setImportModalOpen(false);
           console.log("Import completed successfully.");
        } catch (e) {
          console.error("Import execution error:", e);
          // --- ADD Alert on failure ---
          alert(`Falha ao importar: ${e?.message || e}`);
          // --- END Alert ---
        } finally {
          setIsImporting(false);
        }
      };

      /* ===== Calculations / Memos ===== */

      // Filter and sort expenses based on the current filter and user view
      const filteredAndSortedExpenses = useMemo(() => {
        const toDate = d => d ? new Date(d.split('/').reverse().join('-')) : new Date(0); // Helper to parse 'dd/mm/yyyy'

        // Determine which expenses are visible to the current user
        const userVisible = expenses.filter(e => {
          if (e.type === 'Cartão') {
            const src = e.paymentSource || '';
            if (src.includes('7292')) return true; // Digital card visible to both
            // Show card expenses based on card owner
            return user === 'Guilherme' ? src.includes('2581') : src.includes('1009');
          }
          // Adjustments made by Thais are visible only to Thais in the list, but counted for both in totals
          if (e.type === 'Ajuste') return user === 'Thais'; // Only Thais sees adjustments in her list
          // Show Pix/Boleto based on who paid
          return e.paidBy === user;
        });


        // Apply the selected filter ('Todos', 'Cartão', 'Parcelados', etc.)
        let filtered = userVisible;
        switch (filter) {
          case 'Cartão':     filtered = userVisible.filter(e => e.type==='Cartão' && !e.parcela); break;
          case 'Parcelados': filtered = userVisible.filter(e => !!e.parcela); break;
          case 'Pix':        filtered = userVisible.filter(e => e.type==='Pix'); break;
          case 'Boleto':     filtered = userVisible.filter(e => e.type==='Boleto'); break;
          case 'Ajustes':    filtered = userVisible.filter(e => e.type === 'Ajuste'); break; // Filter adjustments if selected
          default:           filtered = userVisible.filter(e => e.type !== 'Ajuste'); // 'Todos' excludes Ajustes from list by default
        }


        // Sort the filtered expenses
        return filtered.sort((a,b) => {
          const ad = toDate(a.date), bd = toDate(b.date);
          // When 'Todos' filter is active, non-installments come before installments on the same day
          if (filter==='Todos') {
            const ap = !!a.parcela, bp = !!b.parcela;
            if (ap !== bp) return ap ? 1 : -1;
          }
          // Primary sort: newest date first
          return bd - ad;
        });
      }, [expenses, filter, user]); // Recalculate when expenses, filter, or user changes

      // Calculate total amounts for each card (overall, not filtered)
      const cardTotals = useMemo(() => {
        const sum = (needle) => round2(expenses.filter(e => e.type==='Cartão' && (e.paymentSource||'').includes(needle))
          .reduce((s,e)=>s+Number(e.amount||0),0));
        const t2581 = sum('2581'); // Guilherme's card
        const t1009 = sum('1009'); // Thais' card
        const t7292 = sum('7292'); // Digital card
        return { guilhermeCardTotal:t2581, thaisCardTotal:t1009, digitalCardTotal:t7292, grandTotal: round2(t2581+t1009+t7292) };
      }, [expenses]);

      // Calculate Guilherme's and Thais's share based on the selected scope ('geral', 'cartao', 'pixboleto')
      const partsScoped = useMemo(() => {
        let g=0, t=0;
        const base = expenses.filter(e => e.type!=='Ajuste'); // Exclude adjustments from shared calculations
        // Filter expenses based on the selected scope
        const src = scope==='geral' ? base :
                      scope==='cartao' ? base.filter(e=>e.type==='Cartão') :
                      base.filter(e=>e.type==='Pix'||e.type==='Boleto'); // 'pixboleto' scope
        // Calculate shares based on the 'split' field
        for (const e of src) {
          const v = Number(e.amount||0);
          const s = canonicalSplit(e.split); // Normalize split value
          if (s==='Dividido') { g+=v/2; t+=v/2; }
          else if (s==='Guilherme') g+=v;
          else if (s==='Thais') t+=v;
        }
        return { g:round2(g), t:round2(t) };
      }, [expenses, scope]); // Recalculate when expenses or scope changes

      // Calculate Guilherme's and Thais's share specifically for Pix/Boleto expenses (overall)
      const partsPagos = useMemo(() => {
        let g=0, t=0;
        const src = expenses.filter(e => e.type==='Pix' || e.type==='Boleto'); // Only Pix and Boleto
        for (const e of src) {
          const v = Number(e.amount||0);
          const s = canonicalSplit(e.split);
          if (s==='Dividido') { g+=v/2; t+=v/2; }
          else if (s==='Guilherme') g+=v;
          else if (s==='Thais') t+=v;
        }
        return { g:round2(g), t:round2(t) };
      }, [expenses]);

      // Calculate total amount actually paid by Guilherme and Thais (Pix, Boleto, Adjustments) overall
      const { gPaid, tPaid } = useMemo(() => {
        let g=0, t=0;
        const reals = expenses.filter(e => e.type==='Pix' || e.type==='Boleto' || e.type==='Ajuste');
        for (const e of reals) {
          const v = Number(e.amount||0);
          if (e.paidBy==='Guilherme') g+=v; // Digital payments are paid by Gui/Thais via Pix/Boleto, not Digital card itself
          else if (e.paidBy==='Thais') t+=v;
        }
        return { gPaid:round2(g), tPaid:round2(t) };
      }, [expenses]);


      // Calculate overall share for each person (excluding Adjustments)
      const partsGeral = useMemo(() => {
        let g = 0, t = 0;
        const base = expenses.filter(e => e.type !== 'Ajuste'); // Exclude Adjustments
        for (const e of base) {
          const v = Number(e.amount || 0);
          const s = canonicalSplit(e.split);
          if (s === 'Dividido') { g += v/2; t += v/2; }
          else if (s === 'Guilherme') g += v;
          else if (s === 'Thais') t += v;
        }
        return { g: round2(g), t: round2(t) };
      }, [expenses]);

      // Calculate total Pix/Boleto payments made by Thais
      const paidPBThais = useMemo(() => round2(
        expenses
          .filter(e => (e.type === 'Pix' || e.type === 'Boleto') && e.paidBy === 'Thais')
          .reduce((s, e) => s + Number(e.amount || 0), 0)
      ), [expenses]);

      // Calculate total Adjustments paid by Thais to Guilherme
      const ajustesThais = useMemo(() => round2(
        expenses
          .filter(e => e.type === 'Ajuste' && e.paidBy === 'Thais')
          .reduce((s, e) => s + Number(e.amount || 0), 0)
      ), [expenses]);

      // Calculate the final amount Thais owes Guilherme (or vice-versa if negative)
      // Formula: Thais's total share - (Thais's Pix/Boleto payments) - (Thais's Adjustments)
      const saldoDevedorThais = useMemo(() => {
        const raw = (partsGeral.t - paidPBThais - ajustesThais);
        return round2(raw); // Positive = Thais owes Guilherme, Negative = Guilherme owes Thais (or Thais overpaid)
      }, [partsGeral, paidPBThais, ajustesThais]);

      // === Derived values for UI display ===
      const minhaParteFatura = user === 'Guilherme' ? partsScoped.g : partsScoped.t; // Current user's share in the selected scope
      const parteDoOutroFatura = user === 'Guilherme' ? partsScoped.t : partsScoped.g; // Other user's share in the selected scope
      const valorDevolverSePagarTudo = parteDoOutroFatura; // Amount the other user owes if current user pays everything in scope
      const difGastos = round2(Math.abs(partsScoped.g - partsScoped.t)); // Absolute difference in shares within the scope

      // Label indicating who spent more in the current scope
      const quemGastouMaisLabel = (() => {
        if (difGastos < 0.01) return 'Gastos empatados'; // Essentially equal
        const quem = partsScoped.g > partsScoped.t ? 'Guilherme' : 'Thais';
        return user === quem ? 'Você gastou a mais' : `${quem} gastou a mais`;
      })();

      // Dynamic label for the "reimbursement" section based on scope
      const labelQuitarTudo = scope === 'cartao'
        ? `Se você pagar a fatura por inteiro, ${otherUser} te devolve:`
        : `Se você quitar tudo deste filtro, ${otherUser} te devolve:`;

      // Calculate the balance based on Pix/Boleto payments vs shares (overall)
      const gBalance = round2(gPaid - partsPagos.g); // Guilherme's balance (positive means he paid more than his share)
      // User's balance relative to the other user (Pix/Boleto only)
      const saldoUsuario = user === 'Guilherme' ? gBalance : -gBalance; // Thais's balance is the inverse of Guilherme's

      // Determine label and color for the user's Pix/Boleto balance display
      const { saldoLabel, saldoCor } = (() => {
        if (Math.abs(saldoUsuario) < 0.01) return { saldoLabel:'Saldo zerado!', saldoCor:'text-emerald-500' };
        return saldoUsuario > 0
          ? { saldoLabel:`Você tem a receber de ${otherUser}`, saldoCor:'text-emerald-500' } // User is owed money
          : { saldoLabel:`Você deve para ${otherUser}`,   saldoCor:'text-amber-500'  }; // User owes money
      })();

      /* ===== UI Rendering ===== */
      return (
        <div className="max-w-4xl mx-auto p-2 sm:p-4 pb-24"> {/* Main container */}
          {/* Header */}
          <header className="relative mb-6 flex justify-between items-start">
            <div>
              <h1 className="text-3xl font-extrabold">Olá, {user}</h1>
              <p className="text-slate-500 dark:text-slate-400">Resumo das suas despesas.</p>
            </div>
            {/* Logout Button */}
            <button onClick={onLogout}
              className="p-2 rounded-lg bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600"
              aria-label="Trocar de usuário" title="Trocar de usuário">
              <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M10 6H6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h4"/>
                <path d="M14 16l4-4-4-4"/>
                <path d="M8 12h10"/>
              </svg>
            </button>
          </header>

          {/* Summary Cards Grid */}
          <div className="grid gap-4 md:grid-cols-2 mb-6">
            {/* Card Totals Card */}
            <div className="bg-white dark:bg-slate-800 p-6 rounded-2xl shadow-md space-y-3">
              <h3 className="font-semibold text-slate-600 dark:text-slate-400">Total das faturas (cartões)</h3>
              <p className="text-3xl font-extrabold">{formatBRL(cardTotals.grandTotal)}</p>
              <div className="text-xs space-y-1 text-slate-500 dark:text-slate-400">
                <p>Guilherme 2581: <span className="font-semibold text-slate-700 dark:text-slate-300">{formatBRL(cardTotals.guilhermeCardTotal)}</span></p>
                <p>Thais 1009: <span className="font-semibold text-slate-700 dark:text-slate-300">{formatBRL(cardTotals.thaisCardTotal)}</span></p>
                <p>Digital 7292: <span className="font-semibold text-slate-700 dark:text-slate-300">{formatBRL(cardTotals.digitalCardTotal)}</span></p>
              </div>
            </div>

            {/* Balance & Export Card */}
            <div className="bg-white dark:bg-slate-800 p-6 rounded-2xl shadow-md space-y-3">
              <h3 className="font-semibold text-slate-600 dark:text-slate-400">Saldo (Pix/Boleto - Geral)</h3>
              <p className="text-slate-500 dark:text-slate-400">{saldoLabel}</p>
              <p className={`${saldoCor} text-3xl font-extrabold`}>{formatBRL(Math.abs(saldoUsuario))}</p> {/* Show absolute value */}
              <hr className="border-slate-200 dark:border-slate-700" />
              <div className="text-xs text-slate-500 dark:text-slate-400 space-y-1">
                <p>Pagos por você: <span className="font-semibold text-slate-700 dark:text-slate-300">{formatBRL(user === 'Guilherme' ? gPaid : tPaid)}</span></p>
                <p>Pagos por {otherUser}: <span className="font-semibold text-slate-700 dark:text-slate-300">{formatBRL(user === 'Guilherme' ? tPaid : gPaid)}</span></p>
              </div>
              <button onClick={exportXLSX}
                className={`w-full mt-2 px-4 py-2 rounded-lg font-semibold text-white ${theme.bg} ${theme.hover}`}>
                Exportar Relatório
              </button>
            </div>
          </div>

          {/* Adjustment Section (Visible to Guilherme for info, actionable for Thais) */}
          {user === 'Guilherme' && (
            <div className="bg-white dark:bg-slate-800 p-6 rounded-2xl shadow-md space-y-3 mb-6">
              <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
                <div>
                  <h3 className="font-semibold text-slate-600 dark:text-slate-400">
                    Acerto Final (Thais → Guilherme) — Visão Geral
                  </h3>
                  <p className="text-xs text-slate-500 dark:text-slate-400 mt-1">
                    Saldo total considerando Cartões, Pix, Boletos e Ajustes já feitos.
                  </p>
                </div>
                <div className="text-left sm:text-right flex-shrink-0">
                  <p className="text-sm text-slate-500 dark:text-slate-400">Você tem a receber de Thais:</p>
                  <p className={`text-2xl font-extrabold ${saldoDevedorThais >= 0 ? 'text-emerald-600' : 'text-amber-500'}`}>
                    {formatBRL(saldoDevedorThais)}
                  </p>
                  {saldoDevedorThais < 0 && (
                    <p className="text-xs text-amber-500 mt-0.5">
                      (Você deve este valor para Thais)
                    </p>
                  )}
                </div>
              </div>
              <div className="text-xs text-slate-500 dark:text-slate-400 pt-2 border-t border-slate-200 dark:border-slate-700">
                Parte da Thais (geral): <span className="font-semibold text-slate-700 dark:text-slate-300">{formatBRL(partsGeral.t)}</span> •
                Pago por Thais (Pix/Boleto): <span className="font-semibold text-slate-700 dark:text-slate-300">{formatBRL(paidPBThais)}</span> •
                Ajustes Thais → Gui: <span className="font-semibold text-slate-700 dark:text-slate-300">{formatBRL(ajustesThais)}</span>
              </div>
            </div>
          )}

          {user === 'Thais' && (
            <div className="bg-white dark:bg-slate-800 p-6 rounded-2xl shadow-md space-y-4 mb-6">
              <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
                <div>
                  <h3 className="font-semibold text-slate-600 dark:text-slate-400">Lançar Ajuste (Thais → Guilherme)</h3>
                  <p className="text-xs text-slate-500 dark:text-slate-400 mt-1">
                    Registre aqui valores que você pagou diretamente ao Guilherme para abater do saldo devedor.
                  </p>
                </div>
                <div className="text-left sm:text-right flex-shrink-0">
                  <p className="text-sm text-slate-500 dark:text-slate-400">Saldo devedor (geral):</p>
                  <p className={`text-2xl font-extrabold ${saldoDevedorThais > 0 ? 'text-amber-500' : 'text-emerald-600'}`}>
                    {formatBRL(saldoDevedorThais)}
                  </p>
                  <p className="text-xs text-slate-500 dark:text-slate-400 mt-0.5">
                    (Já pago em ajustes: <span className="font-semibold">{formatBRL(ajustesThais)}</span>)
                  </p>
                </div>
              </div>

              {/* Quick Adjustment Form */}
              <div className="grid gap-2 sm:grid-cols-[160px_1fr_auto]">
                <input
                  className="px-3 py-2 rounded-lg bg-slate-100 dark:bg-slate-700 outline-none border border-transparent focus:border-indigo-500"
                  placeholder="Valor (ex: 200,00)"
                  inputMode="decimal"
                  value={ajusteValor}
                  onChange={(e)=>setAjusteValor(e.target.value)}
                />
                <input
                  className="px-3 py-2 rounded-lg bg-slate-100 dark:bg-slate-700 outline-none border border-transparent focus:border-indigo-500"
                  placeholder="Descrição (opcional)"
                  value={ajusteDesc}
                  onChange={(e)=>setAjusteDesc(e.target.value)}
                />
                <button
                  onClick={adicionarAjusteRapido}
                  className="px-4 py-2 rounded-lg font-semibold text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 dark:focus:ring-offset-slate-800"
                >
                  Registrar ajuste
                </button>
              </div>

              <div className="text-xs text-slate-500 dark:text-slate-400 pt-2 border-t border-slate-200 dark:border-slate-700">
                Sua parte total (geral): <span className="font-semibold text-slate-700 dark:text-slate-300">{formatBRL(partsGeral.t)}</span> •
                Pagos por você (Pix/Boleto): <span className="font-semibold text-slate-700 dark:text-slate-300">{formatBRL(paidPBThais)}</span>
              </div>
            </div>
          )}

          {/* Scope Summary Card */}
          <div className="bg-white dark:bg-slate-800 p-6 rounded-2xl shadow-md space-y-4 mb-6">
            <h3 className="font-semibold text-slate-600 dark:text-slate-400">Divisão de Gastos (Filtro Atual)</h3>
            {/* Scope Selection Buttons */}
            <div className="flex flex-wrap gap-2">
              <button onClick={()=>setScope('geral')}
                className={`px-3 py-1.5 rounded-full text-sm font-semibold transition ${scope==='geral' ? `${theme.bg} text-white shadow` : 'bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>Geral (Cartão+Pix+Boleto)</button>
              <button onClick={()=>setScope('cartao')}
                className={`px-3 py-1.5 rounded-full text-sm font-semibold transition ${scope==='cartao' ? `${theme.bg} text-white shadow` : 'bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>Só Cartões</button>
              <button onClick={()=>setScope('pixboleto')}
                className={`px-3 py-1.5 rounded-full text-sm font-semibold transition ${scope==='pixboleto' ? `${theme.bg} text-white shadow` : 'bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>Só Pix e Boletos</button>
            </div>
            {/* Reimbursement Info */}
            <div>
              <p className="text-sm text-slate-500 dark:text-slate-400 mb-1">{labelQuitarTudo}</p>
              <p className={`${theme.text} ${theme.darkText} text-3xl font-extrabold`}>{formatBRL(valorDevolverSePagarTudo)}</p>
            </div>
            <hr className="border-slate-200 dark:border-slate-700" />
            {/* Difference Info */}
            <div>
              <p className="font-semibold text-sm text-slate-600 dark:text-slate-400">{quemGastouMaisLabel}</p>
              <p className="text-sky-500 text-2xl font-bold">{formatBRL(difGastos)}</p>
            </div>
            {/* Share breakdown */}
            <div className="text-sm text-slate-500 dark:text-slate-400">
              <p>Sua parte ({scope}): <span className="font-semibold text-slate-700 dark:text-slate-300">{formatBRL(minhaParteFatura)}</span></p>
              <p>Parte de {otherUser} ({scope}): <span className="font-semibold text-slate-700 dark:text-slate-300">{formatBRL(parteDoOutroFatura)}</span></p>
            </div>
          </div>

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row gap-2 mb-6">
            <button onClick={()=>{setEditingId(null); setIsAddOpen(true);}} // Clear editingId when opening for add
              className={`flex-1 text-white font-semibold py-3 px-4 rounded-xl shadow-lg transition ${theme.bg} ${theme.hover}`}>
              Adicionar Lançamento
            </button>
            <button onClick={()=>fileInputRef.current?.click()}
              className="flex-1 bg-slate-200 dark:bg-slate-700 text-slate-800 dark:text-slate-200 font-semibold py-3 px-4 rounded-xl shadow-lg hover:bg-slate-300 dark:hover:bg-slate-600">
              Importar
            </button>
            {/* Hidden file input triggered by the button above */}
            <input ref={fileInputRef} type="file" className="hidden" accept=".csv,.xlsx,.xls,.ods" onChange={handleFileUpload} />
            <button onClick={()=>setIsClearModalOpen(true)}
              className="flex-1 bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-4 rounded-xl shadow-lg">
              Limpar Tudo
            </button>
          </div>

          {/* Expense List Section */}
          <div className="bg-white dark:bg-slate-800 p-2 sm:p-4 rounded-2xl shadow-md">
            {/* Filter Buttons */}
            <div className="flex flex-wrap gap-2 mb-4 p-2">
              {['Todos','Cartão','Parcelados','Pix','Boleto','Ajustes'].map(opt => (
                <button key={opt} onClick={()=>setFilter(opt)}
                  className={`px-3 py-1.5 rounded-full text-sm font-semibold transition ${
                    filter===opt ? `${theme.bg} text-white shadow` : 'bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600'
                  }`}>
                  {opt}
                </button>
              ))}
            </div>
            {/* Expense List */}
            <div className="space-y-1">
              {filteredAndSortedExpenses.map(expense => {
                const splitCan = canonicalSplit(expense.split); // Normalized split for border color
                return (
                  <div
                    key={expense.id}
                    // Grid layout for expense item: Description/Details | Amount/Actions
                    className={`grid grid-cols-[minmax(0,1fr)_auto] items-center gap-2 p-2 sm:p-3
                           rounded-lg hover:bg-slate-50 dark:hover:bg-slate-700/50 border-l-4 transition-all ${
                             splitCan==='Guilherme' ? 'border-indigo-500' // Blue border for Guilherme's share
                               : splitCan==='Thais' ? 'border-pink-500' // Pink border for Thais' share
                               : 'border-transparent' // No border if split is 'Dividido'
                           }`}
                  >
                    {/* Left Column: Description and Details */}
                    <div className="min-w-0"> {/* Prevents text overflow issues */}
                      <p className="font-semibold truncate text-sm sm:text-base">{expense.description}</p>
                      <p className="text-xs text-slate-500 dark:text-slate-400 truncate">
                        {expense.date} {expense.parcela ? `• ${expense.parcela}` : ''} • {expense.type}
                      </p>
                    </div>

                    {/* Right Column: Chips, Amount, and Actions */}
                    <div className="flex items-center justify-end gap-1 sm:gap-2 whitespace-nowrap">
                      {/* Chips for Paid By / Card Source (hidden on small screens) */}
                      {expense.type !== 'Cartão' && expense.type !== 'Ajuste' && (
                        <span className="hidden sm:inline text-[10px] sm:text-xs px-2 py-0.5 rounded-full bg-slate-200 dark:bg-slate-600 text-slate-700 dark:text-slate-300">
                          Pago: {expense.paidBy}
                        </span>
                      )}
                      {expense.type === 'Cartão' && (
                        <span className="hidden sm:inline text-[10px] sm:text-xs px-2 py-0.5 rounded-full bg-slate-200 dark:bg-slate-600 text-slate-700 dark:text-slate-300">
                          {(expense.paymentSource||'').includes('7292') ? 'Cartão Digital'
                            : (expense.paymentSource||'').includes('1009') ? 'Cartão Thais'
                            : (expense.paymentSource||'').includes('2581') ? 'Cartão Gui'
                            : 'Cartão'}
                        </span>
                      )}

                      {/* Amount */}
                      <p className={`font-semibold text-sm sm:text-base ${expense.amount < 0 ? 'text-emerald-500' : 'text-slate-800 dark:text-slate-200'}`}>
                        {formatBRL(expense.amount)}
                      </p>

                      {/* Edit Button */}
                      <button
                        onClick={() => openEdit(expense)}
                        className="p-2 rounded-lg text-slate-500 hover:bg-slate-200 hover:text-slate-700 dark:hover:bg-slate-600 dark:hover:text-slate-200 ml-1"
                        aria-label="Editar lançamento" title="Editar lançamento"
                      >
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                          <path d="M12 20h9"/>
                          <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L8 18l-4 1 1-4 11.5-11.5Z"/>
                        </svg>
                      </button>

                      {/* Delete Button */}
                      <button
                        onClick={(e)=>{ e.stopPropagation(); openDelete(expense); }} // Prevent row click when deleting
                        className="p-2 rounded-lg text-red-500 hover:bg-red-500/10"
                        aria-label="Excluir lançamento"
                        title="Excluir"
                      >
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                          <path d="M3 6h18"/>
                          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                          <line x1="10" y1="11" x2="10" y2="17"/>
                          <line x1="14" y1="11" x2="14" y2="17"/>
                        </svg>
                      </button>
                    </div>
                  </div>
                );
              })}
              {/* Empty State for Expense List */}
              {filteredAndSortedExpenses.length===0 && (
                <div className="p-4 text-center text-sm text-slate-500 dark:text-slate-400">Sem lançamentos para este filtro.</div>
              )}
            </div>
          </div>

          {/* Add/Edit Modal */}
          <Modal isOpen={isAddOpen} onClose={()=>{setIsAddOpen(false); setEditingId(null); setFParcela('');}}>
            <div className="p-5 space-y-3">
              <h2 id="modal-title" className="text-lg font-semibold">
                {editingId ? 'Editar lançamento' : 'Novo lançamento'}
              </h2>
              {/* Form Fields */}
              <input className="w-full px-3 py-2 rounded-lg bg-slate-100 dark:bg-slate-700 outline-none border border-transparent focus:border-indigo-500" placeholder="Descrição" value={fDesc} onChange={e=>setFDesc(e.target.value)} required />
              {/* --- Input de Valor com Máscara --- */}
              <input
                ref={valorRef}
                className="w-full px-3 py-2 rounded-lg bg-slate-100 dark:bg-slate-700 outline-none border border-transparent focus:border-indigo-500"
                placeholder="0,00"
                inputMode="numeric" /* Melhora experiência mobile */
                pattern="[0-9]*" /* Ajuda na validação */
                value={fValor}
                onChange={handleValorChange}
                required
              />
              {/* --- Fim Input de Valor --- */}
              <input className="w-full px-3 py-2 rounded-lg bg-slate-100 dark:bg-slate-700 outline-none border border-transparent focus:border-indigo-500" placeholder="Data (dd/mm/aaaa)" value={fData} onChange={e=>setFData(e.target.value)} pattern="\d{2}/\d{2}/\d{4}" />

              {/* Installment field (only for Card type) */}
              {fTipo === 'Cartão' && (
                <input
                  className="w-full px-3 py-2 rounded-lg bg-slate-100 dark:bg-slate-700 outline-none border border-transparent focus:border-indigo-500"
                  placeholder="Parcela (ex: 2/12)"
                  value={fParcela}
                  onChange={e => setFParcela(e.target.value)}
                />
              )}

              {/* Type and Split Selects */}
              <div className="flex gap-2">
                <select className="flex-1 px-3 py-2 rounded-lg bg-slate-100 dark:bg-slate-700 outline-none border border-transparent focus:border-indigo-500" value={fTipo} onChange={e=>setFTipo(e.target.value)}>
                  <option>Cartão</option><option>Pix</option><option>Boleto</option><option disabled={user !== 'Thais'}>Ajuste</option> {/* Disable Ajuste for Guilherme */}
                </select>
                <select className="flex-1 px-3 py-2 rounded-lg bg-slate-100 dark:bg-slate-700 outline-none border border-transparent focus:border-indigo-500" value={fSplit} onChange={e=>setFSplit(e.target.value)} disabled={fTipo === 'Ajuste'}> {/* Disable Split for Ajuste */}
                  <option>Dividido</option><option>Guilherme</option><option>Thais</option>
                </select>
              </div>
              {/* Card Source Select (only for Card type) */}
              {fTipo==='Cartão' && (
                <select className="w-full px-3 py-2 rounded-lg bg-slate-100 dark:bg-slate-700 outline-none border border-transparent focus:border-indigo-500" value={fFonte} onChange={e=>setFFonte(e.target.value)}>
                  <option>Cartão Guilherme (final 2581)</option>
                  <option>Cartão Thais (final 1009)</option>
                  <option>Cartão Digital (final 7292)</option>
                </select>
              )}
              {/* Modal Actions */}
              <div className="flex justify-end gap-2 pt-2">
                <button
                  onClick={() => { setIsAddOpen(false); setEditingId(null); setFParcela(''); }} // Close and reset form
                  className="px-4 py-2 rounded-lg bg-slate-200 dark:bg-slate-600 hover:bg-slate-300 dark:hover:bg-slate-500"
                >
                  Cancelar
                </button>
                <button
                  onClick={salvarLancamento}
                  disabled={salvando}
                  className={`px-4 py-2 rounded-lg text-white font-semibold ${theme.bg} ${theme.hover} disabled:opacity-50`}
                >
                  {salvando ? (editingId ? 'Atualizando...' : 'Salvando...') : (editingId ? 'Atualizar' : 'Salvar')}
                </button>
              </div>
            </div>
          </Modal>

          {/* Import Confirmation Modal */}
          <Modal isOpen={isImportModalOpen} onClose={()=>setImportModalOpen(false)}>
            <div className="p-5">
              <h2 id="modal-title" className="text-lg font-semibold mb-2">Confirmar importação</h2>
              <p className="text-sm text-slate-600 dark:text-slate-300 mb-4">
                Encontrados <b>{importedExpenses.length}</b> lançamentos válidos. Lançamentos duplicados (mesma data, valor, descrição, etc.) serão ignorados. Deseja importar agora?
              </p>
              <div className="flex gap-2 justify-end">
                <button onClick={()=>{setImportModalOpen(false); setImportedExpenses([]);}} className="px-4 py-2 rounded-lg bg-slate-200 dark:bg-slate-600 hover:bg-slate-300 dark:hover:bg-slate-500">Cancelar</button>
                <button onClick={confirmImport} className={`px-4 py-2 rounded-lg text-white font-semibold ${theme.bg} ${theme.hover} disabled:opacity-50`} disabled={isImporting}>{isImporting ? 'Importando...' : 'Importar'}</button>
              </div>
            </div>
          </Modal>

          {/* Clear All Data Confirmation Modal */}
          <Modal isOpen={isClearModalOpen} onClose={()=>setIsClearModalOpen(false)}>
            <div className="p-5">
              <h2 id="modal-title" className="text-lg font-semibold mb-2 text-red-600 dark:text-red-500">Apagar todos os dados?</h2>
              <p className="text-sm text-slate-600 dark:text-slate-300 mb-4">Isso irá apagar permanentemente todas as despesas e planos de parcelamento de ambos os usuários. Esta ação não pode ser desfeita.</p>
              <div className="flex gap-2 justify-end">
                <button onClick={()=>setIsClearModalOpen(false)} className="px-4 py-2 rounded-lg bg-slate-200 dark:bg-slate-600 hover:bg-slate-300 dark:hover:bg-slate-500">Cancelar</button>
                <button onClick={confirmAndClearAll} className="px-4 py-2 rounded-lg bg-red-600 hover:bg-red-700 text-white font-semibold">Apagar Tudo</button>
              </div>
            </div>
          </Modal>

          {/* Delete Expense Confirmation Modal */}
          <Modal isOpen={isDelOpen} onClose={closeDelete}>
            <div className="p-5">
              <h2 id="modal-title" className="text-lg font-semibold mb-2 text-red-600 dark:text-red-500">
                Excluir lançamento?
              </h2>
              <p className="text-sm text-slate-600 dark:text-slate-300 mb-4 truncate">
                {delTarget?.description} — {delTarget ? formatBRL(delTarget.amount) : ''} ({delTarget?.date})
              </p>

              {/* Warning for deleting an installment */}
              {delTarget?.installmentPlanId && delTarget?.parcela && (
                <div className="text-xs mb-4 p-2 rounded bg-amber-100 dark:bg-amber-900/30 text-amber-700 dark:text-amber-300">
                  Este lançamento é uma <b>parcela ({delTarget.parcela})</b>. Ao excluir, ela não será recriada automaticamente.
                </div>
              )}

              <div className="flex gap-2 justify-end">
                <button onClick={closeDelete} className="px-4 py-2 rounded-lg bg-slate-200 dark:bg-slate-600 hover:bg-slate-300 dark:hover:bg-slate-500">
                  Cancelar
                </button>
                <button onClick={doDelete} disabled={deleting}
                  className="px-4 py-2 rounded-lg bg-red-600 hover:bg-red-700 text-white font-semibold disabled:opacity-50">
                  {deleting ? 'Excluindo...' : 'Excluir'}
                </button>
              </div>
            </div>
          </Modal>
        </div>
      );
    };

    /* ================= App (Firebase + Root Component) ================= */
    const App = () => {
      // State for current user, Firebase db instance, auth readiness, and errors
      const [currentUser, setCurrentUser] = useState(() => JSON.parse(localStorage.getItem('meuAcertoUser') || 'null'));
      const [db, setDb] = useState(null);
      const [authReady, setAuthReady] = useState(false);
      const [userId, setUserId] = useState(null); // <-- State for userId
      const [error, setError] = useState(null);

      // Get appId from global variable (only relevant for Canvas pathing, not used here)
      const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

      // Initialize Firebase on component mount
      useEffect(() => {
        // --- Use your Firebase config directly when deploying outside Canvas ---
        // Replace with your actual Firebase project config
        // --- FIX: Use the actual config provided by the user ---
        const firebaseConfig = {
          apiKey: "AIzaSyCeecZ8a4rPnf26IItU-HaaeRpcv5xPTkk",
          authDomain: "meu-acerto-app.firebaseapp.com",
          projectId: "meu-acerto-app",
          storageBucket: "meu-acerto-app.appspot.com", // Corrected format
          messagingSenderId: "326844075367",
          appId: "1:326844075367:web:0315e86713b1e0071f33c2"
        };
        // --- END FIX ---
        // --- END Config ---

        try {
          // Initialize Firebase app if not already initialized
          if (!firebase.apps.length) firebase.initializeApp(firebaseConfig); // Use your config

          // Enable Firestore logging
          firebase.firestore.setLogLevel('debug');

          // Get Firestore instance and enable offline persistence with tab synchronization
          const firestoreDb = firebase.firestore();
          firestoreDb.enablePersistence({ synchronizeTabs: true })
            .catch((err) => { console.warn("Firestore persistence error:", err.code); });
          setDb(firestoreDb); // Store db instance in state

          // Firebase Authentication
          const auth = firebase.auth();
          // Listener for authentication state changes
          const unsub = auth.onAuthStateChanged(user => {
            setAuthReady(!!user);
            setUserId(user ? user.uid : null); // <-- Set userId from auth state
          });

          // Sign in anonymously (since there's no custom token outside Canvas)
          (async () => {
            try {
              // Set persistence to local (keeps user signed in across sessions)
              await auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);

              // Sign in anonymously if no current user
              if (!auth.currentUser) {
                console.log("Attempting anonymous sign in...");
                await auth.signInAnonymously();
                console.log("Anonymous sign in successful.");
              } else {
                console.log("User already signed in.");
                setAuthReady(true); // Ensure authReady is true if already signed in
                setUserId(auth.currentUser.uid); // Ensure userId is set
              }
              // The onAuthStateChanged listener will handle setting authReady and userId
            } catch (err) {
              console.error("Firebase Auth Error (Anonymous Sign In):", err);
              setError(`Erro de autenticação: ${err.message}.`);
            }
          })();

          // Cleanup listener on unmount
          return () => unsub();
        } catch (err) {
          console.error("Firebase Initialization Error:", err);
          setError("Falha crítica ao inicializar. O app não pode continuar.");
        }
      }, []); // Run only once on mount

      // Handle user selection
      const handleSelectUser = (u) => {
        setCurrentUser(u);
        localStorage.setItem('meuAcertoUser', JSON.stringify(u)); // Persist selection
      };
      // Handle logout (clear user selection)
      const handleLogout = () => {
        setCurrentUser(null);
        localStorage.removeItem('meuAcertoUser'); // Clear persisted selection
      };

      // Conditional Rendering based on state
      if (error) return <div className="min-h-screen flex items-center justify-center text-red-500 font-semibold p-4 text-center">{error}</div>; // Show error message
      // Wait for db, auth, AND userId
      if (!db || !authReady || !userId) return <div className="min-h-screen flex items-center justify-center text-slate-500 animate-pulse">A ligar ao servidor…</div>; // Show loading indicator
      if (!currentUser) return <UserSelectionScreen onSelectUser={handleSelectUser} />; // Show user selection if no user is selected

      // Show Dashboard if initialized and user is selected
      // Pass appId (might be default) and userId to Dashboard
      return <Dashboard user={currentUser} onLogout={handleLogout} db={db} appId={appId} userId={userId} />;
    };

    // Mount the App component directly after definition
    const rootElement = document.getElementById('root');
    if (rootElement) {
      createRoot(rootElement).render(<App />);
    } else {
      console.error("Root element #root not found for React mounting.");
    }

    // Register Service Worker after window loads
    window.onload = () => {
      // Don't register SW if not available (e.g., local file://)
      if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {
        navigator.serviceWorker.register('sw.js').catch(error => {
          console.warn('Service Worker registration failed:', error);
        });
      }
    };
  </script>
</body>
</html>

